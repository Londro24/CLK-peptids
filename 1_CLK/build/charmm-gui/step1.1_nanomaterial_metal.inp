* GENERATED BY CHARMM-GUI (http://www.charmm-gui.org) v3.7 on Jan, 06. 2026. JOBID=6770207064
* GENERATE NANOMATERIAL STRUCTURE AND COORDINATES
*

DIMENS CHSIZE 5000000 MAXRES 5000000 MAXGRP 5000000

! Read topology and parameter files
stream toppar.str


!
! Read user's settings
!
stream step1.1_user_input.str

calc pi = 4.0 * atan (1.0)

! Start with rectangle, then remove to shape
! Requires determining Lx/Ly/Lz for all cases
!
set type = @{material}@{milidx}
!
!shape determination
!
set XTLtype = triclinic

set shape = cube

if impatch .eq. yes set shape = slab

if rsphere .ne. 0 then
   set shape = sphere
   set Rsphere = @Rsphere
   calc xbx   = @Rsphere * 2 + 5
   calc ybx   = @Rsphere * 2 + 5
   calc zbx   = @Rsphere * 2 + 5
endif
if rcylinder .ne. 0 then
   set shape = cylinder
   set Rcylinder = @rcylinder
   calc ybx   = @Rcylinder * 2
   calc zbx   = @Rcylinder * 2
   if nanorod .eq. 1 then
      set shape = rod
      calc xbx = @xbx + @Rcylinder * 2
   endif
endif
if l_pgon .ne. 0 then
   set shape = polygon
   set l_pgon = @{l_pgon}
   calc xbx = @xbx
   calc ybx = @{l_pgon} * 2 + 5
   calc zbx = @{l_pgon} * 2 + 5
endif

!
! reading unit cell
!
stream nanomaterial/@type_unitcell.str

rename segid raw select segid I@material end

define junk sele .not. init show end
if ?nsel .gt. 0 stop

calc Nx = int ( @xbx / @UA ) + 1
calc Ny = int ( @ybx / @UB ) + 1
calc Nz = int ( @zbx / @UC ) + 1

if wulff .eq. on then
   calc Nx = int ( @Nx / 2 + 1 )  * 2
   calc Ny = int ( @Ny / 2 + 1 )  * 2
   calc Nz = int ( @Nz / 2 + 1 )  * 2
endif

calc d2r = ?pi / 180
calc gsin =  sin( @gamma * @d2r )
calc bsin =  sin( @beta * @d2r )
calc asin =  sin( @alpha * @d2r )
calc gcos =  cos( @gamma * @d2r )
calc bcos =  cos( @beta * @d2r )
calc acos =  cos( @alpha * @d2r )

calc ax = ( @Nx / 2 ) * @UA
calc bx = ( @Ny / 2 ) * @UB * @{gcos}
calc by = ( @Ny / 2 ) * @UB * @{gsin}
calc cx = ( @Nz / 2 ) * @UC * @{bcos}
calc cy = ( @Nz / 2 ) * @UC * (@{acos} - @{gcos} * @{bcos} ) / @{gsin}
calc cz = @Nz * @UC / @{gsin} * sqrt ( 1 - @{acos} * @{acos} - @{bcos} * @{bcos} - @{gcos} * @{gcos} + 2 * @{acos} * @{bcos} * @{gcos} ) / 2

calc orinx = @{ax} + @{bx} + @{cx}
calc oriny = @{by} + @{cy}
calc orinz = @{cz}

calc A = @Nx * @UA
calc B = @Ny * @UB * sin( @gamma * @d2r )
calc C = @cz * 2

autogen nopatch

!
! building nanomaterial crystal
! how many unit cells are there along X/Y/Z?
!
calc Nxy = @Nx * @Ny
set iz = 1
set ix = 1
label dox
   calc ixyp = ( @ix - 1 ) * @Ny
   calc Lx = ( @ix - 1 ) * @UA
   set iy = 1
   label doy
      calc Ly = ( @iy - 1 ) * @UB
      calc isum = @ixyp + @iy
      if isum .eq. 1 then
         generate rawxy duplicate raw setup
         coor duplicate select segid raw end select segid rawxy end
      endif
      if isum .gt. 1 then
         generate temp duplicate raw setup
         coor duplicate select segid raw end select segid temp end
      endif
      ! nanomaterial specific patch(es)
      stream nanomaterial/metal_crystal.str
      if isum .gt. 1 then
         join rawxy TEMP renumber
      endif
   increase iy by 1
   if iy .le. @Ny goto doy

increase ix by 1
if ix .le. @Nx goto dox


calc ix = 1
calc iy = 1
calc iz = 1
label doz

   if iz .eq. 1 then
      generate @{material} setup duplicate rawxy setup
      coor duplicate select segid rawxy end select segid @{material} end
   else
      generate temp duplicate rawxy setup
      coor duplicate select segid rawxy end select segid temp end
      calc Z = @UC * ( @iz - 1 )  ! mult Y by @J3
      coor trans zdir @Z select segid temp end
      join @{material} temp renumber
   endif
   incr iz by 1
if iz .le. @Nz goto doz

delete atom sele segid rawxy end

!
!delete raw unitcell structure
!
delete atom sele segid raw end

coor stat sele all end
coor trans xdir -@orinx ydir -@oriny zdir -@orinz
calc Lx = @Nx * @UA
calc Ly = @Ny * @UB
calc Lz = @Nz * @Uc

!
!
! shaping nanomaterial
!

! edge cutting
if l_edge .ne. 0 then
   set nnn = 4

   calc rotang1 = atan ( @Ly / @Ly ) * 180 / @pi
   calc rotang2 = 180 - @rotang1
   calc rotang3 = 180 + @rotang1
   calc rotang4 = 360 - @rotang1

   calc ldiagonal  = @Ly / 2 / cos ( @rotang1 * @pi / 180 )
   calc lcut = @ldiagonal * ( 1.0 - @{l_edge} )

   calc in = 1
   label cutedge
      coor rotate xdir 1.0 phi @{rotang@@in}
      coor stat
      define target sele .byres. ( prop y .gt. @lcut ) end
      if ?nsel .gt. 0 delete atom sele target end
      coor rotate xdir 1.0 phi -@{rotang@@in}
   increase in by 1
   if in .le. @nnn goto cutedge
endif

! sphere
if rsphere .ne. 0 then
   scalar wmain = x
   scalar wmain POW2r
   scalar wmain store 1
   scalar wmain = y
   scalar wmain POW2r
   scalar wmain +store 1
   scalar wmain = z
   scalar wmain POW2r
   scalar wmain +store 1
   scalar wmain recall 1
   scalar wmain sqrt
   define junk select .byres. ( prop wmain .gt. @Rsphere ) end
   if ?nsel .gt. 0 delete atom select junk end
endif

! cylinder
if rcylinder .ne. 0 then
   scalar wmain = y
   scalar wmain POW2r
   scalar wmain store 1
   scalar wmain = z
   scalar wmain POW2r
   scalar wmain +store 1
   scalar wmain recall 1
   scalar wmain sqrt
   define junk select .byres. ( prop wmain .gt. @Rcylinder ) end
   if ?nsel .gt. 0 delete atom sele junk end

   if nanorod .eq. 1 then
   ! +x
      calc xtran = @Lx / 2
      coor trans xdir -@xtran
      coor trans xdir @Rcylinder
      scalar wmain = x
      scalar wmain POW2r
      scalar wmain store 1
      scalar wmain = y
      scalar wmain POW2r
      scalar wmain +store 1
      scalar wmain = z
      scalar wmain POW2r
      scalar wmain +store 1
      scalar wmain recall 1
      scalar wmain sqrt
      define junk select .byres. ( prop wmain .gt. @Rcylinder .and. prop X .gt. 0 ) end
      if ?nsel .gt. 0 delete atom select junk end

   ! -x
      coor trans xdir -@Rcylinder
      coor trans xdir @Lx
      coor trans xdir -@Rcylinder
      scalar wmain = x
      scalar wmain POW2r
      scalar wmain store 1
      scalar wmain = y
      scalar wmain POW2r
      scalar wmain +store 1
      scalar wmain = z
      scalar wmain POW2r
      scalar wmain +store 1
      scalar wmain recall 1
      scalar wmain sqrt
      define junk select .byres. ( prop wmain .gt. @Rcylinder .and. prop X .lt. 0 ) end
      if ?nsel .gt. 0 delete atom select junk end
      coor trans xdir @Rcylinder
      coor trans xdir -@xtran
   endif
endif

! polygon
if l_pgon .ne. 0 then
   calc rotang = 360 / @nnn
   calc lcut = @{l_pgon} * cos( @rotang / 2 * @pi / 180.0 )

   calc in = 1
   label ncut
      calc phi = ( @in - 1 ) * @rotang
      coor rotate xdir 1.0 phi @rotang
      define target select .byres. ( prop y .gt. @lcut ) end
      if ?nsel .gt. 0 delete atom sele target end
   increase in by 1
   if in .le. @nnn goto ncut
endif


set fname = step1_nanomaterial
!set fname = @type_@shape_@pbc
open write card unit 10 name @fname.psf
write psf unit 10 card

open write card unit 10 name @fname.crd
write coor unit 10 card

open write card unit 10 name @fname.pdb
write coor unit 10 pdb official

if wulff .eq. on then
   coor stat sele all end
   open write unit 90 card name step1_nanomaterial.str

   write title unit 90
   * set ncharge = ?cgtot
   * set xcen = ?xave
   * set ycen = ?yave
   * set zcen = ?zave
   * set Nx = @Nx
   * set Ny = @Ny
   * set Nz = @Nz
   * set A = @A
   * set B = @B
   * set C = @C
   * set alpha = @{alpha}
   * set beta  = @{beta}
   * set gamma = @{gamma}
   * set impatch = @impatch
   *

   open write card unit 10 name init_for_wulff.psf
   write psf unit 10 card

   open write card unit 10 name init_for_wulff.crd
   write coor unit 10 card

   open write card unit 10 name init_for_wulff.pdb
   write coor unit 10 pdb official
endif
if wulff .ne. on then
   open write card unit 10 name step1_nanomaterial.psf
   write psf unit 10 card
   open write card unit 10 name step1_nanomaterial.crd
   write coor unit 10 card
   open write card unit 10 name step1_nanomaterial.pdb
   write coor unit 10 pdb official
   close unit 10

   coor stat sele all end

   calc dcel = 0.5
   calc xdim = int ( ( ?xmax - ?xmin + 5.0 ) / @dcel ) + 1
   calc ydim = int ( ( ?ymax - ?ymin + 5.0 ) / @dcel ) + 1
   calc zdim = int ( ( ?zmax - ?zmin + 5.0 ) / @dcel ) + 1
   calc space = @xdim * @ydim * @zdim

   ! prevent overflow on integer conversion
   calc maxint = 2**32 / 2 - 1
   if space .gt. @maxint calc space = @maxint

   scalar 1 = radius
   scalar 2 set 6.0

   coor volume hole space @space select all end
   calc molvol = ?volume

   set A = @A
   set B = @B
   set C = @C
   coor stat sele all end

   if alpha .eq. @beta then
      if beta .eq. @gamma then
         set XTLtype = ORTHorhombic
         if A .eq. @B if B .ne. @C set XTLtype = TETRagonal
          if A .eq. @B if A .eq. @C set XTLtype = CUBIc
      else
         set XTLtype = Triclinic
      endif
   else
      set XTLtype = Triclinic
   endif

   open write unit 90 card name step1_nanomaterial.str

   write title unit 90
   * set ncharge = ?cgtot
   * set xmax = ?xmax
   * set ymax = ?ymax
   * set zmax = ?zmax
   * set xmin = ?xmin
   * set ymin = ?ymin
   * set zmin = ?zmin
   * set xcen = ?xave
   * set ycen = ?yave
   * set zcen = ?zave
   * set XTLTYPE = @XTLtype
   * set boxtype = rect
   * set Nx = @Nx
   * set Ny = @Ny
   * set Nz = @Nz
   * set alpha = 90
   * set beta  = 90
   * set gamma = 90
   * set molvol = @molvol
   * set A = @A
   * set B = @B
   * set C = @C
   * set impatch = @impatch
   *
endif


